; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\serial.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\serial.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\start -I.\User -I.\Library -I.\System -I.\Hardware -I.\RTE\_Target_1 -ID:\Keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\serial.crf Hardware\Serial.c]
                          THUMB

                          AREA ||i.GetFlagData||, CODE, READONLY, ALIGN=2

                  GetFlagData PROC
;;;109    
;;;110    uint8_t GetFlagData(void)
000000  4805              LDR      r0,|L1.24|
;;;111    {
;;;112    	if (Serial_FlagData == 1)
000002  7800              LDRB     r0,[r0,#0]  ; Serial_FlagData
000004  2801              CMP      r0,#1
000006  d104              BNE      |L1.18|
;;;113    	{
;;;114    		Serial_FlagData = 0;
000008  2000              MOVS     r0,#0
00000a  4903              LDR      r1,|L1.24|
00000c  7008              STRB     r0,[r1,#0]
;;;115    		return 1;
00000e  2001              MOVS     r0,#1
                  |L1.16|
;;;116    	}
;;;117    	return 0;
;;;118    }
000010  4770              BX       lr
                  |L1.18|
000012  2000              MOVS     r0,#0                 ;117
000014  e7fc              B        |L1.16|
;;;119    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      Serial_FlagData

                          AREA ||i.Serial_Init||, CODE, READONLY, ALIGN=2

                  Serial_Init PROC
;;;8      
;;;9      void Serial_Init(void)
000000  b500              PUSH     {lr}
;;;10     {
000002  b087              SUB      sp,sp,#0x1c
;;;11     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;12     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2004              MOVS     r0,#4
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;13     	
;;;14     	GPIO_InitTypeDef GPIO_InitStructure;
;;;15      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000014  2018              MOVS     r0,#0x18
000016  f88d001b          STRB     r0,[sp,#0x1b]
;;;16     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  2003              MOVS     r0,#3
00001c  f88d001a          STRB     r0,[sp,#0x1a]
;;;17     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000020  f44f7000          MOV      r0,#0x200
000024  f8ad0018          STRH     r0,[sp,#0x18]
;;;18      	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a906              ADD      r1,sp,#0x18
00002a  4821              LDR      r0,|L2.176|
00002c  f7fffffe          BL       GPIO_Init
;;;19     	
;;;20     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000030  2048              MOVS     r0,#0x48
000032  f88d001b          STRB     r0,[sp,#0x1b]
;;;21     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000036  2003              MOVS     r0,#3
000038  f88d001a          STRB     r0,[sp,#0x1a]
;;;22     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00003c  f44f6080          MOV      r0,#0x400
000040  f8ad0018          STRH     r0,[sp,#0x18]
;;;23      	GPIO_Init(GPIOA, &GPIO_InitStructure);
000044  a906              ADD      r1,sp,#0x18
000046  481a              LDR      r0,|L2.176|
000048  f7fffffe          BL       GPIO_Init
;;;24     	
;;;25     	USART_InitTypeDef USART_Structure;
;;;26     	USART_Structure.USART_BaudRate = 9600;  //波特率
00004c  f44f5016          MOV      r0,#0x2580
000050  9002              STR      r0,[sp,#8]
;;;27     	USART_Structure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000052  2000              MOVS     r0,#0
000054  f8ad0014          STRH     r0,[sp,#0x14]
;;;28     	USART_Structure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;  
000058  200c              MOVS     r0,#0xc
00005a  f8ad0012          STRH     r0,[sp,#0x12]
;;;29     	USART_Structure.USART_Parity = USART_Parity_No; //校验位
00005e  2000              MOVS     r0,#0
000060  f8ad0010          STRH     r0,[sp,#0x10]
;;;30     	USART_Structure.USART_StopBits = USART_StopBits_1;
000064  f8ad000e          STRH     r0,[sp,#0xe]
;;;31     	USART_Structure.USART_WordLength = USART_WordLength_8b;
000068  f8ad000c          STRH     r0,[sp,#0xc]
;;;32     	USART_Init(USART1, &USART_Structure);
00006c  a902              ADD      r1,sp,#8
00006e  4811              LDR      r0,|L2.180|
000070  f7fffffe          BL       USART_Init
;;;33     	
;;;34     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);  //开启RXNE标志位到NVIC的输出
000074  2201              MOVS     r2,#1
000076  f2405125          MOV      r1,#0x525
00007a  480e              LDR      r0,|L2.180|
00007c  f7fffffe          BL       USART_ITConfig
;;;35     	
;;;36     	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
000080  f44f60a0          MOV      r0,#0x500
000084  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;37     	
;;;38     	NVIC_InitTypeDef NVIC_InitStructure;
;;;39     	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000088  2025              MOVS     r0,#0x25
00008a  f88d0004          STRB     r0,[sp,#4]
;;;40     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00008e  2001              MOVS     r0,#1
000090  f88d0007          STRB     r0,[sp,#7]
;;;41     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000094  f88d0005          STRB     r0,[sp,#5]
;;;42     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000098  f88d0006          STRB     r0,[sp,#6]
;;;43     	NVIC_Init(&NVIC_InitStructure);
00009c  a801              ADD      r0,sp,#4
00009e  f7fffffe          BL       NVIC_Init
;;;44     	
;;;45     	USART_Cmd(USART1, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4803              LDR      r0,|L2.180|
0000a6  f7fffffe          BL       USART_Cmd
;;;46     }
0000aa  b007              ADD      sp,sp,#0x1c
0000ac  bd00              POP      {pc}
;;;47     
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      0x40010800
                  |L2.180|
                          DCD      0x40013800

                          AREA ||i.Serial_Pow||, CODE, READONLY, ALIGN=1

                  Serial_Pow PROC
;;;74     
;;;75     uint32_t Serial_Pow(uint32_t X, uint32_t Y)
000000  b510              PUSH     {r4,lr}
;;;76     {
000002  4602              MOV      r2,r0
;;;77     	uint32_t Result = 1;
000004  2001              MOVS     r0,#1
;;;78     	while (Y --)
000006  e000              B        |L3.10|
                  |L3.8|
;;;79     	{
;;;80     		Result *= X;
000008  4350              MULS     r0,r2,r0
                  |L3.10|
00000a  1e0b              SUBS     r3,r1,#0              ;78
00000c  f1a10101          SUB      r1,r1,#1              ;78
000010  d1fa              BNE      |L3.8|
;;;81     	}
;;;82     	return Result;
;;;83     }
000012  bd10              POP      {r4,pc}
;;;84     
                          ENDP


                          AREA ||i.Serial_SendArray||, CODE, READONLY, ALIGN=1

                  Serial_SendArray PROC
;;;54     
;;;55     void Serial_SendArray(uint8_t *Array, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;56     {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;57     	uint16_t i;
;;;58     	for (i = 0; i < Length; i ++)
000006  2400              MOVS     r4,#0
000008  e004              B        |L4.20|
                  |L4.10|
;;;59     	{
;;;60     		Serial_SendByte(Array[i]);
00000a  5d28              LDRB     r0,[r5,r4]
00000c  f7fffffe          BL       Serial_SendByte
000010  1c60              ADDS     r0,r4,#1              ;58
000012  b284              UXTH     r4,r0                 ;58
                  |L4.20|
000014  42b4              CMP      r4,r6                 ;58
000016  dbf8              BLT      |L4.10|
;;;61     	}
;;;62     	
;;;63     }
000018  bd70              POP      {r4-r6,pc}
;;;64     
                          ENDP


                          AREA ||i.Serial_SendByte||, CODE, READONLY, ALIGN=2

                  Serial_SendByte PROC
;;;48     
;;;49     void Serial_SendByte(uint8_t Byte)
000000  b510              PUSH     {r4,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51     	USART_SendData(USART1, Byte);
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L5.28|
000008  f7fffffe          BL       USART_SendData
;;;52     	while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
00000c  bf00              NOP      
                  |L5.14|
00000e  2180              MOVS     r1,#0x80
000010  4802              LDR      r0,|L5.28|
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L5.14|
;;;53     }
00001a  bd10              POP      {r4,pc}
;;;54     
                          ENDP

                  |L5.28|
                          DCD      0x40013800

                          AREA ||i.Serial_SendNumber||, CODE, READONLY, ALIGN=1

                  Serial_SendNumber PROC
;;;84     
;;;85     void Serial_SendNumber(uint32_t Number, uint8_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;86     {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;87     	uint8_t i;
;;;88     	for (i = 0; i < Length; i ++)
000008  2500              MOVS     r5,#0
00000a  e012              B        |L6.50|
                  |L6.12|
;;;89     	{
;;;90     		Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');
00000c  1b60              SUBS     r0,r4,r5
00000e  1e41              SUBS     r1,r0,#1
000010  200a              MOVS     r0,#0xa
000012  f7fffffe          BL       Serial_Pow
000016  fbb6f0f0          UDIV     r0,r6,r0
00001a  210a              MOVS     r1,#0xa
00001c  fbb0f2f1          UDIV     r2,r0,r1
000020  fb010012          MLS      r0,r1,r2,r0
000024  f1000730          ADD      r7,r0,#0x30
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       Serial_SendByte
00002e  1c68              ADDS     r0,r5,#1              ;88
000030  b2c5              UXTB     r5,r0                 ;88
                  |L6.50|
000032  42a5              CMP      r5,r4                 ;88
000034  dbea              BLT      |L6.12|
;;;91     	}
;;;92     }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;93     
                          ENDP


                          AREA ||i.Serial_SendPacket||, CODE, READONLY, ALIGN=2

                  Serial_SendPacket PROC
;;;101    
;;;102    void Serial_SendPacket(void)
000000  b510              PUSH     {r4,lr}
;;;103    {
;;;104    	Serial_SendByte(0xFF);
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       Serial_SendByte
;;;105    	Serial_SendArray(Serial_TxPacket, 4);
000008  2104              MOVS     r1,#4
00000a  4803              LDR      r0,|L7.24|
00000c  f7fffffe          BL       Serial_SendArray
;;;106    	Serial_SendByte(0xFE);
000010  20fe              MOVS     r0,#0xfe
000012  f7fffffe          BL       Serial_SendByte
;;;107    }
000016  bd10              POP      {r4,pc}
;;;108    
                          ENDP

                  |L7.24|
                          DCD      Serial_TxPacket

                          AREA ||i.Serial_SendString||, CODE, READONLY, ALIGN=1

                  Serial_SendString PROC
;;;64     
;;;65     void Serial_SendString(char *String)
000000  b570              PUSH     {r4-r6,lr}
;;;66     {
000002  4604              MOV      r4,r0
;;;67     	uint16_t i;
;;;68     	for (i = 0; String[i] != '\0'; i ++) 
000004  2500              MOVS     r5,#0
000006  e004              B        |L8.18|
                  |L8.8|
;;;69     	{
;;;70     		Serial_SendByte(String[i]);
000008  5d60              LDRB     r0,[r4,r5]
00000a  f7fffffe          BL       Serial_SendByte
00000e  1c68              ADDS     r0,r5,#1              ;68
000010  b285              UXTH     r5,r0                 ;68
                  |L8.18|
000012  5d60              LDRB     r0,[r4,r5]            ;68
000014  2800              CMP      r0,#0                 ;68
000016  d1f7              BNE      |L8.8|
;;;71     	}
;;;72     	
;;;73     }
000018  bd70              POP      {r4-r6,pc}
;;;74     
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;120    
;;;121    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	static uint8_t RxState = 0;
;;;124    	static uint8_t PR = 0;
;;;125    	if(USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
000002  f2405125          MOV      r1,#0x525
000006  481e              LDR      r0,|L9.128|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d136              BNE      |L9.126|
;;;126    	{
;;;127    		uint8_t RXData = USART_ReceiveData(USART1);
000010  481b              LDR      r0,|L9.128|
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c4              UXTB     r4,r0
;;;128    		
;;;129    		if(RxState == 0)
000018  481a              LDR      r0,|L9.132|
00001a  7800              LDRB     r0,[r0,#0]  ; RxState
00001c  b940              CBNZ     r0,|L9.48|
;;;130    		{
;;;131    			if(RXData == 0xFF)
00001e  2cff              CMP      r4,#0xff
000020  d127              BNE      |L9.114|
;;;132    			{
;;;133    				RxState = 1;
000022  2001              MOVS     r0,#1
000024  4917              LDR      r1,|L9.132|
000026  7008              STRB     r0,[r1,#0]
;;;134    				PR = 0;
000028  2000              MOVS     r0,#0
00002a  4917              LDR      r1,|L9.136|
00002c  7008              STRB     r0,[r1,#0]
00002e  e020              B        |L9.114|
                  |L9.48|
;;;135    			}
;;;136    		}
;;;137    		else if(RxState == 1)
000030  4814              LDR      r0,|L9.132|
000032  7800              LDRB     r0,[r0,#0]  ; RxState
000034  2801              CMP      r0,#1
000036  d110              BNE      |L9.90|
;;;138    		{
;;;139    			Serial_RxPacket[PR] = RXData;
000038  4814              LDR      r0,|L9.140|
00003a  4913              LDR      r1,|L9.136|
00003c  7809              LDRB     r1,[r1,#0]  ; PR
00003e  5444              STRB     r4,[r0,r1]
;;;140    			PR ++;
000040  4811              LDR      r0,|L9.136|
000042  7800              LDRB     r0,[r0,#0]  ; PR
000044  1c40              ADDS     r0,r0,#1
000046  4910              LDR      r1,|L9.136|
000048  7008              STRB     r0,[r1,#0]
;;;141    			if(PR >= 4)
00004a  4608              MOV      r0,r1
00004c  7800              LDRB     r0,[r0,#0]  ; PR
00004e  2804              CMP      r0,#4
000050  db0f              BLT      |L9.114|
;;;142    			{
;;;143    				RxState = 2;
000052  2002              MOVS     r0,#2
000054  490b              LDR      r1,|L9.132|
000056  7008              STRB     r0,[r1,#0]
000058  e00b              B        |L9.114|
                  |L9.90|
;;;144    			}
;;;145    		}
;;;146    		else if(RxState == 2)
00005a  480a              LDR      r0,|L9.132|
00005c  7800              LDRB     r0,[r0,#0]  ; RxState
00005e  2802              CMP      r0,#2
000060  d107              BNE      |L9.114|
;;;147    		{
;;;148    			if(RXData == 0xFE)
000062  2cfe              CMP      r4,#0xfe
000064  d105              BNE      |L9.114|
;;;149    			{
;;;150    				RxState = 0;
000066  2000              MOVS     r0,#0
000068  4906              LDR      r1,|L9.132|
00006a  7008              STRB     r0,[r1,#0]
;;;151    				Serial_FlagData = 1;
00006c  2001              MOVS     r0,#1
00006e  4908              LDR      r1,|L9.144|
000070  7008              STRB     r0,[r1,#0]
                  |L9.114|
;;;152    			}
;;;153    		}
;;;154    		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
000072  f2405125          MOV      r1,#0x525
000076  4802              LDR      r0,|L9.128|
000078  f7fffffe          BL       USART_ClearITPendingBit
;;;155    	}
00007c  bf00              NOP      
                  |L9.126|
;;;156    }
00007e  bd10              POP      {r4,pc}
                          ENDP

                  |L9.128|
                          DCD      0x40013800
                  |L9.132|
                          DCD      RxState
                  |L9.136|
                          DCD      ||PR||
                  |L9.140|
                          DCD      Serial_RxPacket
                  |L9.144|
                          DCD      Serial_FlagData

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;93     
;;;94     int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;96     	Serial_SendByte(ch);
000006  b2e0              UXTB     r0,r4
000008  f7fffffe          BL       Serial_SendByte
;;;97     	return ch;
00000c  4620              MOV      r0,r4
;;;98     }
00000e  bd70              POP      {r4-r6,pc}
;;;99     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  Serial_TxPacket
                          DCDU     0x00000000
                  Serial_RxPacket
                          DCDU     0x00000000
                  Serial_FlagData
000008  00                DCB      0x00
                  RxState
000009  00                DCB      0x00
                  ||PR||
00000a  00                DCB      0x00
